let sleep = require('util').promisify(setTimeout);
const { ethers } = require('hardhat');
const axios = require('axios');
const hre = require("hardhat");
// @ts-ignore
import { time, expectEvent } from '@openzeppelin/test-helpers';
import { toBN } from '../../test/utils/test-helpers';
import { 
    IFtsoRegistryInstance, 
    IVoterWhitelisterInstance,
    IPriceSubmitterInstance,
    IFtsoInstance,
} from "../../typechain-truffle";

// TODO(MCZ): improve to get more accurate time
async function getTime(): Promise<number>{
    await time.advanceBlock();
    const blockNum = await ethers.provider.getBlockNumber();
    const block = await ethers.provider.getBlock(blockNum);
    const timestamp = block.timestamp;
    return timestamp
}

export function submitPriceHash(price: number, random: number, address: string,): string {
    return ethers.utils.keccak256(ethers.utils.defaultAbiCoder.encode([ "uint256", "uint256", "address" ], [ price.toString(), random.toString(), address]))
}

// TODO: Implement this to read prices from interesting places
function getPrice(epochId: number, asset: string): number{
    return Math.floor(Math.random() * 200 + 10000);
}

// TODO: abstract out API call to a different function to easily switch between APIs
async function getPrices(epochId: number, assets: string[]): Promise<number[]>{
    // return Math.floor(Math.random() * 200 + 10000);

    // Get prices
    var baseCurrency = 'USD';
    var ccApiKey = process.env.CC_API_KEY;
    var ccApiUrl = `https://min-api.cryptocompare.com/data/pricemulti?fsyms=${assets.join()}&tsyms=${baseCurrency}&api_key=${ccApiKey}`;
    // console.log(ccApiUrl);

    try {
        var pricesRaw = (await axios.get(ccApiUrl)).data;
        var prices = assets.map(sym => pricesRaw[sym][baseCurrency])
        return prices;
    } catch(error){
        console.log(`Price API error:\n  ${error}`);
        return assets.map((sym, i) => 0);   // Return 0's, TOOD: update
    }
}

// TODO: Maybe change random generation
function getRandom(epochId: number, asset: string): number{
    return Math.floor(Math.random() * 1000);
}

const MockPriceSubmitter = artifacts.require("MockPriceSubmitter");
const MockFtsoRegistry = artifacts.require("MockFtsoRegistry");
const MockVoterWhitelister = artifacts.require("MockVoterWhitelister");
const MockFtso = artifacts.require("MockNpmFtso");

async function main() {
    console.log(`Times:`)
    console.log(await getTime());
    console.log((new Date()).getTime());
    // Just the first from autogenerated accounts
    // TODO(MCZ): update
    const priceProviderPrivateKey = "0xc5e8f61d1ab959b397eecc0a37a6517b8e67a0e7cf1f4bce5591f3ed80199122";
    const priceProviderAccount = web3.eth.accounts.privateKeyToAccount(priceProviderPrivateKey);

    // Initialize data
    
    // Price submitter is at a fixed address, change this to the address reported by `yarn hh_node`.
    let priceSubmitterAddr;
    if (hre.network.name == 'songbird') {
        // special fixed address
        priceSubmitterAddr = '0x1000000000000000000000000000000000000003';
    }
    else {
        // get from yarn hh_node
        // TODO(MCZ): upgrade to https://hardhat.org/plugins/hardhat-deploy.html
        priceSubmitterAddr = '0x7c2C195CD6D34B8F845992d380aADB2730bB9C6F'; 
    }
    const priceSubmitter: IPriceSubmitterInstance = await MockPriceSubmitter.at(priceSubmitterAddr);

    const ftsoRegistry: IFtsoRegistryInstance = await MockFtsoRegistry.at(await priceSubmitter.getFtsoRegistry());
    const voterWhitelister: IVoterWhitelisterInstance = await MockVoterWhitelister.at(await priceSubmitter.getVoterWhitelister());

    console.log(`Addresses:`)
    console.log(`\tpriceSubmitter:      ${priceSubmitter.address}`)     // 0x1000000000000000000000000000000000000003   
    console.log(`\tftsoRegistry:        ${ftsoRegistry.address}`)       // 0x6D222fb4544ba230d4b90BA1BfC0A01A94E6cB23
    console.log(`\tvoterWhitelister:    ${voterWhitelister.address}`)   // 0xa76906EfBA6dFAe155FfC4c0eb36cDF0A28ae24D

    // Get indices for specific symbols
    // const symbols = ["SGB", "XRP", "LTC", "XLM", "XDG", "ADA", "ALGO", "BCH", "DGB", "BTC"];
    // const symbols = ['XRP',  'LTC', 'XLM', 'DOGE', 'ADA', 'ALGO', 'BCH',  'DGB', 'BTC', 'ETH',  'FIL'];
    // const prices = await getPrices(1, symbols);
    // console.log("Prices: ", prices);
    const ftsoSupportedIndices = (await ftsoRegistry.getSupportedIndices()).map(idx => (idx.toNumber()));
    const symbols = await Promise.all(
        ftsoSupportedIndices.map(async idx => await ftsoRegistry.getFtsoSymbol(idx))
    );
    // const prices = await getPrices(1, symbols);
    // console.log("Symbols: ", symbols);
    // console.log("Prices: ", prices);

    const ftsos = await Promise.all(
        symbols.map(async sym => await MockFtso.at(await ftsoRegistry.getFtsoBySymbol(sym)))
    ) as IFtsoInstance[];

    // Get addresses of the various FTSO contracts
    // const ftsoAddresses = await Promise.all(
    //     symbols.map(async sym => await ftsoRegistry.getFtsoBySymbol(sym))
    // );
    const ftsoAddresses = await ftsoRegistry.getAllFtsos();

    // Get indices on which to submit
    // const ftsoIndices = await Promise.all(
    //     symbols.map(async sym => (await ftsoRegistry.getFtsoIndex(sym)).toNumber())
    // )
    const ftsoIndices = ftsoSupportedIndices;

    // Combine them for easier future use
    const currencyIndices = new Map(
        symbols.map((c, i) => [c, ftsoIndices[i]]) 
    );

    // Get whitelists and counts
    const ftsoWhitelists = await Promise.all(
        ftsoSupportedIndices.map(async idx => await voterWhitelister.getFtsoWhitelistedPriceProviders(idx))
    );
    const ftsoWhitelistsCounts = new Map( 
        symbols.map((c, i) => [c, ftsoWhitelists[i].length])
    );
    console.log(`FTSO Whitelist counts:`);
    console.log(ftsoWhitelistsCounts);

    // Whitelist ourselves for EVERY ftso. This always works in mock case
    // since there is no vote power calculation, so everyone gets whitelisted.
    // In a real setting, this call can be quite expensive and can potentially fail
    // if the voter does not have enough power or provide enough gas for the transaction
    const tx = await voterWhitelister.requestFullVoterWhitelisting(priceProviderAccount.address);
    // Check the whitelist for any changes
    const whitelist = await priceSubmitter.voterWhitelistBitmap(priceProviderAccount.address);

    // Get submission config
    const {
        0: firstEpochStartTimeBN,
        1: submitPeriodBN,
        2: revealPeriodBN,
    } = (await ftsos[0].getPriceEpochConfiguration());

    const [firstEpochStartTime, submitPeriod, revealPeriod] = 
        [firstEpochStartTimeBN, submitPeriodBN, revealPeriodBN].map(x => x.toNumber());

    // Average block time: https://songbird-explorer.flare.network/
    // 2.6 secs as of 2021-10-10
    const avgBlockTime = 2.6;
    console.log(`FTSO parameters:`);
    console.log(`\tfirstEpochStartTime: ${new Date(firstEpochStartTime * 1000)}`);
    console.log(`\tsubmitPeriod (blks): ${submitPeriod}`);
    console.log(`\tsubmitPeriod (secs): ${submitPeriod * avgBlockTime}`);
    console.log(`\trevealPeriod (blks): ${revealPeriod}`);
    console.log(`\trevealPeriod (secs): ${revealPeriod * avgBlockTime}`);

    // Sync time to start on next full transaction id
    // For a real setting, make sure that computer time is synced with a reliable time provider
    // Take blockchain time
    let now = await getTime();  // TODO(MCZ): confirm time
    const startingEpoch = (Math.floor((now - firstEpochStartTime) / submitPeriod) + 1);
    let next = startingEpoch * submitPeriod + firstEpochStartTime;
    let diff = Math.floor(next - now) + 1;
    console.log(`Waiting for ${diff} seconds until first start`); 
    await sleep(diff * 1000);

    let currentEpoch = startingEpoch;
    while(true){
        // Force hardhat to mine a new block which will have an updated timestamp. if we don't hardhat timestamp will not update.
        time.advanceBlock();    // TODO(MCZ): update to check on block
        console.log("Start submit for epoch: ", currentEpoch); 
        // Prepare prices and randoms
        const randoms = symbols.map(sym => getRandom(currentEpoch, sym)); 
        // Just a mock here, real price should not be random
        // const prices = symbols.map(sym => getPrice(currentEpoch, sym)); 
        const prices = await getPrices(currentEpoch, symbols);

        // const pricesPrint = symbols.map((sym, i) => [sym, prices[i]]);
        // console.log(pricesPrint);

        const hashes = prices.map((p, i) => 
            submitPriceHash(p, randoms[i], priceProviderAccount.address)
        );
        console.log("Prices: ", prices);
        console.log("Randoms: ", randoms);
        // Submit price, on everything
        const submission = await priceSubmitter.submitPriceHashes(currentEpoch, 
            ftsoIndices, hashes, {from: priceProviderAccount.address}
        );
        expectEvent(submission, "PriceHashesSubmitted", { ftsos: ftsoAddresses, 
            epochId: currentEpoch.toString(), hashes: hashes});

        currentEpoch = currentEpoch + 1; // TODO(MCZ): maybe need to wait for epoch change

        now = await getTime();
        next = currentEpoch * submitPeriod + firstEpochStartTime;
        diff = Math.floor(next - now);
        console.log(`Waiting for ${diff} seconds until reveal`); 
        await sleep(diff * 1000);
        
        // Reval prices
        time.advanceBlock();
        const reveal = await priceSubmitter.revealPrices(currentEpoch - 1, ftsoIndices, prices, randoms, {from: priceProviderAccount.address});
        await expectEvent(reveal, "PricesRevealed", { ftsos: ftsoAddresses,
            epochId: (currentEpoch - 1).toString(), prices: prices.map(x => toBN(x)) });

        console.log("Revealed prices for epoch ", currentEpoch - 1);
        // start loop again, the price submission has already started
    }
}
   
main()
    .then(() => process.exit(0))
    .catch(error => {
    console.error(error);
    process.exit(1);
});

