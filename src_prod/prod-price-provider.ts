/*
    Imports
*/
const ccxt = require ('ccxt');
require('dotenv').config();
let sleep = require('util').promisify(setTimeout);
const axios = require('axios');
const { ethers } = require("ethers");
var Web3 = require('web3');
const { fromWei } = Web3.utils;
const EthTx = require("ethereumjs-tx");
const math = require("mathjs");
const nodemailer = require("nodemailer");
var url = require('url');
const {BigQuery} = require('@google-cloud/bigquery');
// @ts-ignore
import { time } from '@openzeppelin/test-helpers';  // TODO: get rid of this
import { exit } from 'process';

var orig = console.log

console.log = function log() {
    orig.apply(console, [`${process.pid} `, ...arguments])
}
  
class ftsoConfig {
    URL0: string;
    URL1: string;
    privKey: string;
    baseCurrency: string;
    baseCurrencyAltsRaw: string;
    priceSource: string;
    priceSourceBackup: string;
    exchangeSource: string;
    volumeWeight: boolean;
    useSystemTime: boolean;
    constantBuffer: boolean;
    submitBufferMin: number;
    convertUsdt: boolean;
    gmail_user: string;
    gmail_password: string;
    error_mail_list: string;
    network: string;
    constant_buffer: boolean;
    convert_usdt: boolean;
    cc_api_key: string;
    coinapi_key: string;
    cmc_pro_api_key: string;
    baseCurrencyAlts: string[];
    baseCurrencyLower: string;
    exchanges: string[];
    web3: any;
    web3_backup: any;
    isTestnet: boolean;
    priceSubmitterAddr: string;
    priceProviderPrivateKey: string;
    transporter: any;
    checkPrices: boolean;
    exchangesObjs: any;
    priceProviderAccount: any;

    public ftsoConfig() {}
    
};
 
let cConfig  = new ftsoConfig();
let nConfig = new ftsoConfig();
let shouldInitialize: boolean;
function parseConfigEnv(config: ftsoConfig)
{
    config.URL0 = process.env.RPC_NODE_URL0;
    config.URL1 = process.env.RPC_NODE_URL1;
    config.privKey = process.env.FTSO_PRIVATE_KEY ?? '';
    const web3ProviderOptions = {
        // Need a lower timeout than the default of 750 seconds in case it hangs
        timeout: 60 * 1000, // milliseconds,
    };
    config.web3 = new Web3(
        new Web3.providers.HttpProvider(config.URL0, web3ProviderOptions)
    );
    config.web3_backup = new Web3(
        new Web3.providers.HttpProvider(config.URL1, web3ProviderOptions)
    );
    // var baseCurrency = 'USD';
    config.baseCurrency = process.env.BASE_CURRENCY || 'USD';
    config.baseCurrencyAltsRaw = process.env.BASE_CURRENCY_ALTS || '';   // enable multiple alternative bases
    if (config.baseCurrencyAltsRaw.length == 0) {
        config.baseCurrencyAlts = []; 
    } else {
        config.baseCurrencyAlts = config.baseCurrencyAltsRaw.replace(/\s/g,'').split(',');
    }
    config.baseCurrencyLower = config.baseCurrency.toLowerCase();
    config.priceSource = process.env.PRICE_SOURCE || '';
    config.priceSourceBackup = process.env.PRICE_SOURCE_BACKUP || '';
    config.exchangeSource = process.env.EXCHANGE_SOURCE || '';
    config.exchanges = config.exchangeSource.replace(/\s/g,'').split(',');
    config.volumeWeight = (process.env.VOLUME_WEIGHT || 'FALSE') == 'TRUE' ? true : false;
    config.useSystemTime = (process.env.USE_SYSTEM_TIME || 'FALSE') == 'TRUE' ? true : false;
    config.constantBuffer = (process.env.CONSTANT_BUFFER || 'FALSE') == 'TRUE' ? true : false;
    config.submitBufferMin = parseInt(process.env.SUBMIT_BUFFER_MIN || '18');
    config.convertUsdt = (process.env.CONVERT_USDT || 'FALSE') == 'TRUE' ? true : false;
    config.cc_api_key = process.env.CC_API_KEY;
    config.coinapi_key = process.env.COINAPI_KEY;
    config.cmc_pro_api_key = process.env.CMC_PRO_API_KEY;
    config.network = process.env.NETWORK;
    if (config.network == 'songbird') {
        // Songbird config
        config.isTestnet = false;
    } else if (config.network == 'flare') {
        // Flare config
        config.isTestnet = false;
    } else if (config.network == 'localhost') {
        config.isTestnet = true;
    } else {
        // default assume prod
        config.isTestnet = false;
    }
    if (config.isTestnet) {
        config.priceSubmitterAddr = '0x7c2C195CD6D34B8F845992d380aADB2730bB9C6F';
        // Just the first from autogenerated accounts
        config.priceProviderPrivateKey = "0xc5e8f61d1ab959b397eecc0a37a6517b8e67a0e7cf1f4bce5591f3ed80199122";
    } else {
        config.priceSubmitterAddr = '0x1000000000000000000000000000000000000003';
    }

    config.gmail_user = process.env.GMAIL_USER || '';
    config.error_mail_list = process.env.ERROR_MAIL_LIST ||'';
    config.gmail_password = process.env.GMAIL_PASSWORD || '';
        // Email for notifications
    // create reusable transporter object using the default SMTP transport
    config.transporter = nodemailer.createTransport({
        host: "smtp.gmail.com",
        port: 465,
        secure: true, // true for 465, false for other ports
        auth: {
            user: config.gmail_user,
            pass: config.gmail_password
        },
    });
    config.checkPrices = (process.env.CHECK_PRICES || 'FALSE') == 'TRUE' ? true : false;

    config.exchangesObjs = config.exchanges.map((ex) => new ccxt[ex]({}));
    var exchangesMarkets = (async () => { await Promise.all(config.exchangesObjs.map((ex) => ex.load_markets())) }) ()

    // Get Price Provider account based on the config
    config.priceProviderAccount = config.web3.eth.accounts.privateKeyToAccount(`0x${config.privKey}`);
    config.web3.eth.accounts.wallet.add(config.priceProviderAccount);
    config.web3.eth.defaultAccount = config.priceProviderAccount.address;
    config.web3_backup.eth.accounts.wallet.add(config.priceProviderAccount);
    config.web3_backup.eth.defaultAccount = config.priceProviderAccount.address;
    
}
function parseConfigURL(config: ftsoConfig, request: any)
{
    try{
        var url_parts = url.parse(request.url, true);
        var query = url_parts.query;
        if(request.query.full!="")
        {
            config.URL0 = request.query.rpc_node_url0 ?? '';
            config.URL1 = request.query.rpc_node_url1 ?? '';
            config.privKey = request.query.ftso_private_key ?? '';

            // var baseCurrency = 'USD';
            config.baseCurrency = request.query.base_currency || 'USD';
            config.baseCurrencyAltsRaw = request.query.base_currency_alts || '';   // enable multiple alternative bases
            if (config.baseCurrencyAltsRaw.length == 0) {
                config.baseCurrencyAlts = []; 
            } else {
                config.baseCurrencyAlts = config.baseCurrencyAltsRaw.replace(/\s/g,'').split(',');
            }
            config.baseCurrencyLower = config.baseCurrency.toLowerCase();
            config.priceSource = request.query.price_source || '';
            config.priceSourceBackup = request.query.priceSourceBackup || '';
            config.exchangeSource = request.query.exchange_source || '';
            config.exchanges = config.exchangeSource.replace(/\s/g,'').split(',');
            config.volumeWeight = true;
            config.useSystemTime = false;
            config.constantBuffer = (request.query.constant_buffer || 'FALSE') == 'TRUE' ? true : false;
            config.submitBufferMin = parseInt(request.query.submit_buffer_min || '18');
            config.convertUsdt = (request.query.convert_usdt || 'FALSE') == 'TRUE' ? true : false;
            config.cc_api_key = request.query.cc_api_key;
            config.coinapi_key = request.query.coinapi_key;
            config.cmc_pro_api_key = request.query.cmc_pro_api_key;
            config.network = request.query.network;
            if (config.network == 'songbird') {
                // Songbird config
                config.isTestnet = false;
            } else if (config.network == 'flare') {
                // Flare config
                config.isTestnet = false;
            } else if (config.network == 'localhost') {
                config.isTestnet = true;
            } else {
                // default assume prod
                config.isTestnet = false;
            }
            if (config.isTestnet) {
                config.priceSubmitterAddr = '0x7c2C195CD6D34B8F845992d380aADB2730bB9C6F';
                // Just the first from autogenerated accounts
                config.priceProviderPrivateKey = "0xc5e8f61d1ab959b397eecc0a37a6517b8e67a0e7cf1f4bce5591f3ed80199122";
            } else {
                config.priceSubmitterAddr = '0x1000000000000000000000000000000000000003';
            }

            config.gmail_user = request.query.gmail_user || '';
            config.error_mail_list = request.query.error_mail_list ||'';
            config.gmail_password = request.query.gmail_password || '';
                // Email for notifications
        
            config.checkPrices = (request.query.check_prices || 'FALSE') == 'TRUE' ? true : false;
        }
        else
        {

        }
    }
    catch (err)
    {
        console.log(err);
    }

    
}
function loadConfig(config: ftsoConfig)
{
     // create reusable transporter object using the default SMTP transport
     config.transporter = nodemailer.createTransport({
        host: "smtp.gmail.com",
        port: 465,
        secure: true, // true for 465, false for other ports
        auth: {
            user: config.gmail_user,
            pass: config.gmail_password
        },
    });

    const web3ProviderOptions = {
        // Need a lower timeout than the default of 750 seconds in case it hangs
        timeout: 60 * 1000, // milliseconds,
    };
    config.web3 = new Web3(
        new Web3.providers.HttpProvider(config.URL0, web3ProviderOptions)
    );
    config.web3_backup = new Web3(
        new Web3.providers.HttpProvider(config.URL1, web3ProviderOptions)
    );

    config.exchangesObjs = config.exchanges.map((ex) => new ccxt[ex]({}));
    var exchangesMarkets = (async () => { await Promise.all(config.exchangesObjs.map((ex) => ex.load_markets())) }) ()

    // Get Price Provider account based on the config
    config.priceProviderAccount = config.web3.eth.accounts.privateKeyToAccount(`0x${config.privKey}`);
    config.web3.eth.accounts.wallet.add(config.priceProviderAccount);
    config.web3.eth.defaultAccount = config.priceProviderAccount.address;
    config.web3_backup.eth.accounts.wallet.add(config.priceProviderAccount);
    config.web3_backup.eth.defaultAccount = config.priceProviderAccount.address;
    cConfig = config;
}
// BigQuery setup
const bigquery = new BigQuery();
/*
    Helper Functions
*/

// TODO(MCZ): improve to get more accurate time
// Average block time: https://songbird-explorer.flare.network/
// 2.6 secs as of 2021-10-10
// So this could be off by around 2.6 seconds (plus some extra consensus time sync error)
// Returns UNIX time in seconds 
// const useSystemTime = true;
// System time on Google Cloud Compute should be pretty accurate
// Source 1: https://morganpeat.github.io/cloudmigration/2019/02/01/time-sync-on-cloud-vms-2.html
// Source 2: https://cloud.google.com/compute/docs/instances/managing-instances#configure-ntp
async function getTime(web3: any): Promise<number>{
    if (cConfig.useSystemTime) {
        return (new Date()).getTime() / 1000;
    } else {
        if (cConfig.isTestnet) {
            await time.advanceBlock();
        }
        const blockNum = await web3.eth.getBlockNumber();
        const block = await web3.eth.getBlock(blockNum);
        const timestamp = block.timestamp;
        return timestamp as number;
    }
}


// Return time in seconds
// http://worldtimeapi.org/api
async function getTimeWTA(): Promise<number>{
    const worldTimeApiUrl = `http://worldtimeapi.org/api/timezone/Europe/London`;
    const requestOptions = {
        method: 'GET',
        url: worldTimeApiUrl,
        params: {
        },
        headers: {
        },
    };
    try {
        let response = await axios.request(requestOptions);
        let dt = response.data.unixtime || (new Date()).getTime() / 1000;
        return dt;
    } catch(error){
        console.log(`World Time API error:\n  ${error}`);
        return (new Date()).getTime() / 1000;
    }    
}
// // Testing
// console.log(`Time diffs:`);
// var timeDiffs = [];
// for (let i=0; i<100;i++) {
//     let timeWTA = await getTimeWTA();
//     let timeSys = new Date().getTime() / 1000;
//     let diff = timeSys - timeWTA;
//     timeDiffs.push(diff)
//     console.log(`\tRun ${i} diff: ${diff}`);
// }
// console.log(`Average diff: ${math.mean(timeDiffs)}`);


export function submitPriceHash(price: number, random: string, address: string, web3: any): string {
    return ethers.utils.keccak256(ethers.utils.defaultAbiCoder.encode([ "uint256", "uint256", "address" ], [price.toString(), random.toString(), address]))
}

// Use mathjs instead
// // Find average value of an array
// function calculateAverage(array) {
//     var total = 0;
//     var count = 0;

//     array.forEach(function(item, index) {
//         total += item;
//         count++;
//     });

//     return total / count;
// }


var pricesLast = {};    // Dictionary of arrays indexed by assets (in case we are ever calling for different sets of assets)
// TODO: have this and child functions return a validPrice flag (boolean)
// Decimals: number of decimal places in Asset USD price
// note that the actual USD price is the integer value divided by 10^Decimals
async function getPrices(epochId: number, assets: string[], decimals: number[], priceSource: string): Promise<number[]>{
    var assetsUid = assets.join(',');   // key on asset list as unique identifier
    var nAssets = assets.length;
    if (nAssets == 0) {
        return [];
    }
    // if we haven't initialized last price, start it off with -1s
    if (!(assetsUid in pricesLast)) {
        pricesLast[assetsUid] = new Array(nAssets).fill(-1);
    }
    // Get prices
    try {
        let prices, pxsAll;
        switch (priceSource) {
            case 'CCXT':
                let ccxtRet = await getPricesCCXT(assets);
                // [prices, pxsAll] 
                prices = ccxtRet[0]
                break;
            case 'CRYPTOCOMPARE':
                prices = await getPricesCryptoCompare(assets);
                break;
            case 'COINAPI':
                prices = await getPricesCoinApi(assets);
                break;
            case 'CMC':
                prices = await getPricesCMC(assets);
                break;
            case 'COINGECKO':
                prices = await getPricesCoinGecko(assets);  // no API key needed
                break;
            case 'MODEL_USD_USDT_WEIGHTED':
                prices = await getPricesModel_USD_USDT_Weighted(epochId, assets);
                break;
            case 'ERROR':
                // Error case for testing
                prices = new Array(nAssets).fill(-1);
                break;
            default:
                prices = await getPricesCryptoCompare(assets);
                break;
        }
        // var validPrice = prices.reduce((partial_sum, a) => partial_sum + a,0) > 0;
        // var validPrice = prices[0] > 0;
        var validPrice = math.sum(prices.map(p => p >= 0)) == assets.length;
        // Check if price source function returned array of -1, signalling an error
        if (!validPrice) {
            // Try getting backup prices, recursively
            if (priceSource != cConfig.priceSourceBackup) {
                console.log(`Getting backup prices...`)
                let pricesBackup = getPrices(epochId, assets, decimals, cConfig.priceSourceBackup)
                let pricesBlended = prices.map((value, idx) => isNaN(value) ? pricesBackup[idx] : value);
                // check to see if it's now valid
                validPrice = math.sum(pricesBlended.map(p => p >= 0)) == assets.length;
            }
        }
        var pricesAdj = prices.map((p,i) => Math.round(p * 10**decimals[i]));
        // Check again i we have valid prices, otherwise return last known
        if (!validPrice) {
            // If invalid, return last valid pricing
            pricesAdj = pricesLast[assetsUid];
        } else {
            // store last prices
            pricesLast[assetsUid] = pricesAdj;
        }
        return pricesAdj;
    } catch(error){
        console.log(`Get prices error:\n  ${error}`);
        // return assets.map((sym, i) => -1);   // Return 0's, TOOD: update - maybe return last prices?
        // If invalid, return last valid pricing
        return pricesLast[assetsUid];
    }
}


// Get modeled price
//   Model overview
//   We want to find lambda s.t.
//       Price = lambda * usd_price + (1 - lambda) * usdt_price
//   Since people are clearly not converting from USDT to USD numeraire and just averaging USDT and USD prices
//   Rearranging:
//       Price = usdt_price + lambda * (usd_price - usdt_price)
//       (Price - usdt_price) = lambda * (usd_price - usdt_price)
//   Run regression without intercept to find least squares fit for lambda
//   Price premium to USDT is some fraction of USD px's premium to USDT px
//   Then need to test predicting price for period n using USDT and USD prices for period n plugged into 
//   a model fitted on data through period n-1
async function getPricesModel_USD_USDT_Weighted(epochId: number, assets: string[]): Promise<number[]>{
    // Get prices
    try {
        let ccxtRet = await getPricesCCXT(assets);
        // let ccxtPrices = ccxtRet[0];
        let ccxtPxsAll = ccxtRet[1];
        let ccPrices = await getPricesCryptoCompare(assets);

        let pxsUSDT = assets.map(a => ccxtPxsAll['USDT'][a]);
        let useCcForUsd = true;
        let pxsUSD;
        // Option 1: Use CryptoCompare prices in lieu of direct USD prices (a bit more reliable)
        if (useCcForUsd) {
            pxsUSD = ccPrices;
        }
        // Option 2: USD prices
        else {
            pxsUSD = assets.map(a => ccxtPxsAll['USD'][a]);
            pxsUSD = pxsUSD.map((value, idx) => isNaN(value) ? ccPrices[idx] : value);
        }

        // Get model info from BigQuery
        let modelId = 'USD_USDT_Weighting_Regression';
        // let query = `
        //     SELECT MAX(epochId) as lastEpoch
        //     FROM \`bbftso-329118.FTSO.ModelParams\`
        //     WHERE modelId = "${modelId}"`;

        let query = `
            SELECT * FROM \`bbftso-329118.FTSO.ModelParams\` 
            WHERE epochId = (SELECT MAX(epochId) FROM \`bbftso-329118.FTSO.ModelParams\` WHERE modelId='${modelId}')
            AND modelId = '${modelId}'`;
        var lambdaDefault = 0.5;   // default to simple average
        try {
            var modelParamsData = (await bigquery.query(query))[0];
            var lambdas = {};
            modelParamsData.forEach(row => {
                let lam = Number(row['value']);
                let score = Number(row['score']);
                if (lam < 0 || lam > 1 || (epochId-row['epochId']) > 250) {
                    lam = lambdaDefault;
                }
                // can condition on score as well
                // TODO: add more quality checks
                lambdas[row['symbol']] = lam;
            });
            var lambdaCalc: any[] = assets.map((asset) => lambdas[asset]);
            console.log(`Model params fetched for BigQuery for epoch ${modelParamsData[0]['epochId']}`);
            console.log(`    Lambdas: ${lambdaCalc}`);
        }
        catch(error) {
            console.log(`BigQuery error:\n  ${error}`);
            var lambdaCalc: any[] = assets.map((asset) => lambdaDefault);
        }
        
        // let modelPrices = math.add(math.multiply(lambda, pxsUSD), math.multiply((1 - lambda), pxsUSDT));
        let modelPrices = math.add(
                math.dotMultiply(lambdaCalc, pxsUSD), 
                math.dotMultiply(math.subtract(1, lambdaCalc), pxsUSDT)
            );
        return modelPrices;
    } catch(error){
        console.log(`Get prices error:\n  ${error}`);
        // return assets.map((sym, i) => -1);   // Return 0's, TOOD: update - maybe return last prices?
        // If invalid, return last valid pricing
        return assets.map((sym, i) => -1);
    }
}


function populateQuoteVolume(tickerData: any): any{
    if(tickerData.quoteVolume == null) {
        tickerData.quoteVolume = tickerData.baseVolume * ((tickerData.bid + tickerData.ask) / 2);
    }
    return tickerData;
}

// CCXT
// https://github.com/ccxt/ccxt
// https://ccxt.readthedocs.io/en/latest/manual.html#price-tickers
// list of exchanges: https://ccxt.readthedocs.io/en/latest/manual.html#exchanges
// Initialize bring outside the function to save time each iteration
// https://ccxt.readthedocs.io/en/latest/manual.html#loading-markets

async function getPricesCCXT(assets: string[]): Promise<[number[], {}]> {
    if(cConfig.exchanges.length == 0)
    {
        console.error("CCXT chosen but no exchange source, exiting")
        process.exit(1);
    }
    var string = "";
    cConfig.exchanges.forEach(function(element){
        string += element + " ";
    });
    console.log("Ex Src: ", string);


    let basesCombined = [cConfig.baseCurrency, ...cConfig.baseCurrencyAlts];

    //['XRP/USD`, 'LTC/USD' ...]
    let tickersBase = assets.map((sym) => `${sym}/${cConfig.baseCurrency}`);
    // [][] -> ['XRP/USDT`, `LTC/USDT` ...][`XRP/BTC`, `LTC/BTC` ...]
    let tickersBaseAlts = cConfig.baseCurrencyAlts.map(baseCurrencyAlt => assets.map((sym) => `${sym}/${baseCurrencyAlt}`));
    //[] -> [XRP/USDT`, `LTC/USDT`..., `XRP/BTC`, `LTC/BTC`...]
    let tickersBaseAltsFlat = tickersBaseAlts.reduce((partial_list, a) => [...partial_list, ...a], []);
    // Note: Only Kraken, Coinbase, and FTX has USDT/USD pair: https://coinmarketcap.com/currencies/tether/markets/
    //[] -> [`USDT/USD`, `USDT/BTC`]
    let tickersAltsToBase = cConfig.baseCurrencyAlts.map((alt) => `${alt}/${cConfig.baseCurrency}`);
    // let baseCurrencyAltToBaseCurrencyTicker = `${baseCurrencyAlt}/${baseCurrency}`;
    //[] -> [`XRP/USD`, `LTC/USD`,... `XRP/USDT`, `LTC/USDT`..., `XRP/BTC`, `LTC/BTC`...]
    let tickersFull = [...new Set([...tickersBase, ...tickersBaseAltsFlat, ...tickersAltsToBase])];     // deduplication with Set
    // Map [`XRP` -> `XRP/USD`]
    let tickersBaseToSymbolsMap = new Map(assets.map((sym, i) => [sym, tickersBase[i]]));       // doesn't include USD/USDT
    // let tickersBaseAltToSymbolsMap = new Map(assets.map((sym, i) => [sym, tickersBaseAltsFlat[i]]));
    
    let pxsEx = {};     // arrays of prices for each ticker
    let volsEx = {};    // arrays of volumes for each ticker (in base pair numeraire)
    // let formattedSingleRawData = {};
    try {
        let bulkPxPromises: any[] = [];
        let singlePxPromises: any[] = [];

        // Bulk fetch exchanges
        let bulkFetchIdxs = cConfig.exchangesObjs.map((ex, idx) => ex.has[`fetchTickers`] || false);
        let bulkTickerExs = cConfig.exchangesObjs.filter((ex, i) => bulkFetchIdxs[i])
        bulkPxPromises = bulkTickerExs.map((ex, idx) => ex.fetchTickers(tickersFull));
        
        // individual ticker exchanges
        // Only do for Coinbase
        // TODO: add more single ticker exchanges, like Kraken
        // let usdTickers = tickersFull.filter((ticker, idx) => ticker.split('/')[1] == 'USD')
        let singleTickerExs = cConfig.exchangesObjs.filter((ex, i) => !bulkFetchIdxs[i] && ex.id == 'coinbasepro')
        for (let singleTickerEx of singleTickerExs) {
            if (singleTickerEx.id == 'coinbasepro') {
                let singleTickerExSupportedTickers = tickersFull.filter((ticker, idx) => singleTickerEx.symbols.includes(ticker))
                // let singleTickerExSupportedTickers = tickersFull.filter((ticker, idx) => Object.keys(singleTickerEx.markets).includes(ticker))

                // TODO: this may cause too many request issues, may need to loop individually over each ticker as we did previously
                // push rather than concat to have parallel structure as bulkPxPromises of a separate array for each exchange
                singlePxPromises.push(singleTickerExSupportedTickers.map((ticker, idx) => singleTickerEx.fetchTicker(ticker)))
            }
        }
        
        // Note unsupported exchanges
        let unsupportedExs = cConfig.exchangesObjs.filter((ex, i) => !bulkFetchIdxs[i] && ex.id != 'coinbasepro')
        if (unsupportedExs.length > 0) {
            console.log(`Warning! Unsupported exchanges: ${unsupportedExs.map((ex,idx) => ex.id).join(', ')}`)
        }
        
        // Resolve promises
        let bulkPxData = await Promise.all(bulkPxPromises);
        let singlePxDataList = await Promise.all(singlePxPromises.map(Promise.all.bind(Promise)));    // Need to resolve array of array of promises
        // Convert from array of arrays of quotes to an array of dicts of {symbol: quote}
        let singlePxData = singlePxDataList.map((exResList, i) => {
            let exResDict = {};
            exResList.forEach((quote: any)=> {exResDict[quote.symbol] = quote});
            return exResDict;
        });
        // Concatenate the two data sources
        let allRawData = bulkPxData.concat(singlePxData);
        
        // Sort the raw data into various tickers

        let tickersRet: any[] = [];
        for (let i = 0; i < allRawData.length; i++) {
            //console.log(allRawData[i]);
            tickersRet = Object.keys(allRawData[i]); // will typically be missing a bunch of keys
            //console.log("tickerRet:", tickersRet);
            // Iterate through all price pairs for the same asset (XRP/USD, XRP/USDT, XRP/BTC...)
            // and convert them to USD based and push them into an array. After we iterate through
            // the entire array, we convert them to a single volume weighted average.
            tickersRet.forEach(tickerSymbol => {
                pxsEx[tickerSymbol] = pxsEx[tickerSymbol] || [];
                pxsEx[tickerSymbol].push(
                    (allRawData[i][tickerSymbol].bid + allRawData[i][tickerSymbol].ask) / 2
                );
                volsEx[tickerSymbol] = volsEx[tickerSymbol] || [];
                volsEx[tickerSymbol].push(
                    populateQuoteVolume(allRawData[i][tickerSymbol]).quoteVolume || 0
                );
            });
        };

        // get prices for alternative base currencies
        // Calculate weighted average
        // Could do this recursively (e.g. use BTC/USDT and BTC/USD to calculate BTC/USD rate), but for now keep it simple
        let baseAltsPxs = tickersAltsToBase.map((altTicker, idx) => 
            math.dot(pxsEx[altTicker], volsEx[altTicker]) / math.sum(volsEx[altTicker])
        );

        let baseAltPxsMap = new Map(cConfig.baseCurrencyAlts.map((alt, idx) => [alt, baseAltsPxs[idx]]));
        baseAltPxsMap.set(cConfig.baseCurrency, 1);
        if (!cConfig.convertUsdt) {
            baseAltPxsMap.set('USDT', 1);
        }

        // Get to volume weighted price for each asset
        // TODO: alternative 1: can change to matrix version using math.js and (tickersBase.map((ticker) => pxsEx.get(ticker)))
        // TODO: add an exchange-level weighting factor, s.t. weight = volume * exchange_factor, to reflect exchange quality of volume
        // let pxsAll = {}
        // let pxsAll = new Map(basesCombined.map((base, idx) => [base, {}]));
        var pxsAll = {};
        basesCombined.forEach(base => pxsAll[base] = {});
        let prices = assets.map((asset, idx) => {
            let pxsBase = [];
            let volsBase = [];
            // convert each set of quotes for each base to global base (USD)
            for (let base of basesCombined) {
                let ticker = `${asset}/${base}`;
                if ((pxsEx[ticker] || []).length > 0) {
                    pxsBase.push(...math.dotMultiply(pxsEx[ticker] || [], baseAltPxsMap.get(base)));
                    if (cConfig.volumeWeight) {
                        volsBase.push(...math.dotMultiply(volsEx[ticker] || [], baseAltPxsMap.get(base)));
                        pxsAll[base][asset] = math.dot(pxsEx[ticker], volsEx[ticker]) / math.sum(volsEx[ticker]);
                    } else {
                        volsBase.push(...(new Array((pxsEx[ticker] || []).length).fill(1)));
                        pxsAll[base][asset] = math.mean(pxsEx[ticker]);
                    }
                } else if (asset==base) {
                    pxsAll[base][asset] = 1;
                } else {        
                    pxsAll[base][asset] = NaN;
                }
            }
            if (pxsBase.length == 0) {
                // no prices for the asset on the given exchanges, return NaN
                return NaN;
            } else {
                return math.dot(pxsBase, volsBase) / math.sum(volsBase);
            }
        });

        // // Temporary hacky work around for case when no prices are returned for an asset
        // // assets.filter((asset, idx)  => isNaN(prices[idx]))
        // for (let i=0; i<assets.length; i++) {
        //     if (isNaN(prices[i])) {
        //         let ccPrice = await getPricesCryptoCompare([assets[i]]);
        //         prices[i] = ccPrice[0];
        //     }
        // }

        return [prices, pxsAll];

        // // TODO: alternative 2: allRawData.map()
        // combinedExs = bulkTickerExs.concat(singleTickerExs)
        // let quotesFlat = allRawData.map((exRets, i) => {
        //     return Object.entries(exRets).map(([ticker, quote], j) => {
        //         return {
        //             'exchangeId': combinedExs[i].id,
        //             'ticker': ticker,
        //             'asset': quote['symbol'].split('/')[0],
        //             'base': quote['symbol'].split('/')[1], 
        //             'bid': quote['bid'],
        //             'ask': quote['ask'],
        //             'mid': (quote['bid'] + quote['ask'])/2,
        //             'volume': quote['quoteVolume'],
        //         };
        //     });
        // }).reduce((partial_list, a) => [...partial_list, ...a], []);

    }
    catch(error){
        console.log(`CCXT API error:\n  ${error}`);
        return [assets.map((sym, i) => -1), {}];
    }
}

// TODO: Add in PRICE_SOURCE_BACKUP

// CryptoCompare price API
// **Issue**: poor decimal precision
async function getPricesCryptoCompare(assets: string[]): Promise<number[]>{
    // Get prices
    var ccApiKey = cConfig.cc_api_key;
    var ccApiUrl = `https://min-api.cryptocompare.com/data/pricemulti?fsyms=${assets.join()}&tsyms=${cConfig.baseCurrency}&api_key=${ccApiKey}`;
    try {
        var pricesRaw = (await axios.get(ccApiUrl)).data;
        var prices = assets.map(sym => pricesRaw[sym][cConfig.baseCurrency])
        return prices;
    } catch(error){
        console.log(`CryptoCompare API error:\n  ${error}`);
        return assets.map((sym, i) => -1);
    }
}

// CoinAPI price API
// https://docs.coinapi.io/#md-docs
// List of asset symbols: https://www.coinapi.io/integration
// Detail on how market price is calculated: https://support.coinapi.io/hc/en-us/articles/360018953291-How-are-exchange-rates-calculated-
// TODO: need to switch to websockets for live data per https://docs.coinapi.io/#md-rest-api
// **issue** updates on a > 2 min frequency from empirical testing
async function getPricesCoinApi(assets: string[]): Promise<number[]>{
    // Get prices
    const coinApiKey = cConfig.coinapi_key;
    const coinApiUrl = `https://rest.coinapi.io/v1/exchangerate/${cConfig.baseCurrency}?filter_asset_id=${assets.join(";")};`;    // need trailing semicolon, invert doesn't work
    const requestOptions = {
        method: 'GET',
        url: coinApiUrl,
        headers: {
            'X-CoinAPI-Key': coinApiKey
        }
    };
    try {
        var response = await axios.request(requestOptions);
        var bulkRates = response.data.rates;     // returns in alphabetical order
        // Can do this once at beginning outside of this function since this won't change unless another asset is added halfway, in which case we need to restart anyway...
        var idxMap: Map<string, number> = new Map( bulkRates.map((rateObj, i) => [rateObj.asset_id_quote, i]));
        // confirm lengths to ensure we got all symbols
        if (bulkRates.length != assets.length) {
            throw 'Incorrect number of assets from CoinAPI';
        }
        // need to invert since invert flag doesn't work in API if we are also filtering by asset
        var prices = assets.map( (sym, i) => 1 / bulkRates[idxMap.get(sym) ?? -1].rate );        // janky hack to get typescript to not complain about return type
        return prices;
    } catch(error){
        console.log(`CoinAPI API error:\n  ${error}`);
        return assets.map((sym, i) => -1);
    }    
}

// CoinMarketCap price API
// https://coinmarketcap.com/api/documentation/v1/#operation/getV1CryptocurrencyQuotesLatest
// Has a 60 second cache per the above, so not a very good option
async function getPricesCMC(assets: string[]): Promise<number[]>{
    // Get prices
    const cmcKey = cConfig.cmc_pro_api_key;
    const cmcUrl = `https://pro-api.coinmarketcap.com/v1/cryptocurrency/quotes/latest`;
    const requestOptions = {
        method: 'GET',
        url: cmcUrl,
        params: {
            'symbol': `${assets.join(",")}`,
            'convert': `${cConfig.baseCurrency}`
        },
        headers: {
            'X-CMC_PRO_API_KEY': cmcKey
        },
    };
    try {
        var response = await axios.request(requestOptions);
        var prices = assets.map((sym, i) => response.data.data[sym].quote[cConfig.baseCurrency]['price']);
        return prices;
    } catch(error){
        console.log(`CoinMarketCap API error:\n  ${error}`);
        return assets.map((sym, i) => -1);
    }    
}


// CoinGecko price API
// JS docs: https://github.com/miscavage/CoinGecko-API
// API docs: https://www.coingecko.com/en/api/documentation
// **Issue**: poor decimal precision
// Also has a very bad update frequency of 1 to 10 minutes per https://www.coingecko.com/en/faq
// NOTE: Needs to be updated per coin list: https://docs.google.com/spreadsheets/d/1wTTuxXt8n9q7C4NDXqQpI3wpKu1_5bGVmP9Xz0XGSyU/edit
const cgSymbolMapping = {
    'XRP': 'ripple',
    'LTC': 'litecoin',
    'XLM': 'stellar',
    'DOGE': 'dogecoin',
    'ADA': 'cardano',
    'ALGO': 'algorand',
    'BCH': 'bitcoin-cash',
    'DGB': 'digibyte',
    'BTC': 'bitcoin',
    'ETH': 'ethereum',
    'FIL': 'filecoin',
};
const cgNames = Object.values(cgSymbolMapping)
async function getPricesCoinGecko(assets: string[]): Promise<number[]>{
    const coinGeckoUrl = `https://api.coingecko.com/api/v3/simple/price`;
    const requestOptions = {
        method: 'GET',
        url: coinGeckoUrl,
        params: {
            'ids': `${cgNames.join(",")}`,
            'vs_currencies': cConfig.baseCurrencyLower,
        },
        headers: {},
    };

    try {
        //// Option 1: CoinGecko js client
        // const CoinGecko = require('coingecko-api');
        // const CoinGeckoClient = new CoinGecko();
        // var response = await CoinGeckoClient.simple.price({ ids: cgNames, vs_currencies: [baseCurrencyLower], });
        //// Option 2: CoinGecko API
        var response = await axios.request(requestOptions);
        var prices = assets.map(sym => response.data[cgSymbolMapping[sym]][cConfig.baseCurrencyLower]);     // assumes that cgSymbolMapping is complete
        return prices;
    } catch(error){
        console.log(`CoinGecko API error:\n  ${error}`);
        return assets.map((sym, i) => -1);
    }    
}


// Random generation for hashing of prices to submit in commit phase
function getRandom(epochId: number, asset: string): string{
    // return Math.floor(Math.random() * 1e10);
    return cConfig.web3.utils.randomHex(32);
}


/*
    Configuration
*/


function printConfig(config: ftsoConfig)

{
console.log('Configuration:')
console.log(`    Network:          ${config.network}`)
console.log(`    Node URL0:        ${config.URL0}`)
console.log(`    Node URL1:        ${config.URL1}`)
console.log(`    isTestnet:        ${config.isTestnet}`)
console.log(`    baseCurrency      ${config.baseCurrency     }`);
console.log(`    baseCurrencyAlts  ${config.baseCurrencyAlts }`);
console.log(`    baseCurrencyAltsRaw   ${config.baseCurrencyAltsRaw  }`);
console.log(`    convertUsdt       ${config.convertUsdt      }`);
console.log(`    priceSource       ${config.priceSource      }`);
console.log(`    exchanges         ${config.exchanges        }`); 
console.log(`    volumeWeight      ${config.volumeWeight     }`);
console.log(`    useSystemTime     ${config.useSystemTime    }`);
console.log(`    constantBuffer    ${config.constantBuffer   }`);
console.log(`    submitBufferMin   ${config.submitBufferMin  }`);
console.log(`    providerAccount   ${config.web3.eth.accounts.privateKeyToAccount(`0x${config.privKey}`).address}`);
console.log(`    convertUsdt   ${config.convertUsdt  }`);
console.log(`    gmail_user   ${config.gmail_user  }`);
console.log(`    error_mail_list   ${config.error_mail_list  }`);
console.log(`    cc_api_key   ${config.cc_api_key  }`);
console.log(`    coinapi_key   ${config.coinapi_key  }`);
console.log(`    cmc_pro_api_key   ${config.cmc_pro_api_key  }`);
console.log(`    submitBufferMin   ${config.submitBufferMin  }`);

}

/*
    Main price provider server
*/

async function main() {
    shouldInitialize = true;
    // Express.js server for monitoring
    const express = require('express');
    const app = express();

    app.get('/', (req, res) => {
        console.log('PING.');
        const target = process.env.TARGET || 'Running';
        res.send(`FTSO: ${target}!`);
    });

    app.get('/test', function(request, response) {
        var id = request.query.id;
        var name = request.query.name;
        console.log('id:'+id);
        console.log('name:'+name);
        response.send('id')
      })
      
      app.get('/updateconfig', function(request, response) {
        var id = request.query.id;
        parseConfigURL(nConfig, request);
        shouldInitialize=true;
        printConfig(nConfig);
        response.send('FTSO Config update complete - reinitializing...');
      })

    const port = process.env.PORT || 8080;
    app.listen(port, () => {
        console.log('FTSO Listening on', port);
    });

    parseConfigEnv(nConfig);

    printConfig(nConfig);


    var errorCount, submitBuffer, submitTimes, submitBufferStd, submitBufferBase, submitBufferBurnIn, now, currentEpoch, nextEpoch, diff;
    var decimals;
    var symbols: string[];
    var firstEpochStartTime, submitPeriod, revealPeriod;
    var priceSubmitterAbi, MockFtsoRegistry, MockVoterWhitelister, MockFtso, priceSubmitterContract, ftsoRegistry, voterWhitelister, ftsoIndices, submitBufferMax;
    while (true) {

        if(shouldInitialize)
        {
            loadConfig(nConfig);
            // Times
            console.log(`\n\n\Initializing FTSO provider on ${cConfig.isTestnet ? 'testnet' : 'mainnet'}`);
            console.log(`\tStart time: ${Date()}`); 
            console.log(`Time check:`);
            console.log(`\tChain time:  ${await getTime(cConfig.web3)}`);
            console.log(`\tSystem time: ${(new Date()).getTime() / 1000}`);

             priceSubmitterAbi = require("./priceSubmitter.json");
             MockFtsoRegistry = require("./MockFtsoRegistry.json");
             MockVoterWhitelister = require("./MockVoterWhitelister.json");
             MockFtso = require("./MockNpmFtso.json")
             priceSubmitterContract = new cConfig.web3.eth.Contract(JSON.parse(JSON.stringify(priceSubmitterAbi)), cConfig.priceSubmitterAddr);
             ftsoRegistry = new cConfig.web3.eth.Contract(JSON.parse(JSON.stringify(MockFtsoRegistry)), await priceSubmitterContract.methods.getFtsoRegistry().call());
             voterWhitelister = new cConfig.web3.eth.Contract(JSON.parse(JSON.stringify(MockVoterWhitelister)), await priceSubmitterContract.methods.getVoterWhitelister().call());
            
        

            // Get balance of addresses
            var sgbBalance = fromWei((await cConfig.web3.eth.getBalance(cConfig.priceProviderAccount.address)).toString());
            console.log(`FTSO provider address: ${cConfig.priceProviderAccount.address}`);
            console.log(`          SGB Balance: ${sgbBalance}`);


            console.log(`Addresses:`)
            console.log(`\tpriceSubmitter:   ${priceSubmitterContract.options.address}`)    // 0x1000000000000000000000000000000000000003   
            console.log(`\tftsoRegistry:     ${ftsoRegistry.options.address}`)              // 0x6D222fb4544ba230d4b90BA1BfC0A01A94E6cB23
            console.log(`\tvoterWhitelister: ${voterWhitelister.options.address}`)          // 0xa76906EfBA6dFAe155FfC4c0eb36cDF0A28ae24D

            // Get indices for specific symbols
            // const symbols = ['XRP',  'LTC', 'XLM', 'DOGE', 'ADA', 'ALGO', 'BCH',  'DGB', 'BTC', 'ETH',  'FIL'];
            // Note: this can be replaced by a single call based on live contract

            const ftsoSupportedIndices_ = await ftsoRegistry.methods.getSupportedIndices().call();
            const ftsoSupportedIndices = ftsoSupportedIndices_.map(idx => (parseInt(idx)));
            symbols = await Promise.all(
                ftsoSupportedIndices.map(async idx => await ftsoRegistry.methods.getFtsoSymbol(idx).call())
            );

            const ftsos = await Promise.all(
                symbols.map(async sym =>  new cConfig.web3.eth.Contract(JSON.parse(JSON.stringify(MockFtso)), await ftsoRegistry.methods.getFtsoBySymbol(sym).call()))
            );

            // Get addresses of the various FTSO contracts
            decimals = await Promise.all(
                ftsos.map(async ftso => parseInt((await ftso.methods.ASSET_PRICE_USD_DECIMALS().call())))
            );

            // Get indices on which to submit
            // const ftsoIndices = await Promise.all(
            //     symbols.map(async sym => (await ftsoRegistry.getFtsoIndex(sym)).toNumber())
            // )
            ftsoIndices = ftsoSupportedIndices;

            // Combine them for easier future use
            const currencyIndices = new Map(
                symbols.map((c, i) => [c, ftsoIndices[i]]) 
            );

            // Get whitelists and counts
            const ftsoWhitelists = await Promise.all(
                ftsoSupportedIndices.map(async idx => await voterWhitelister.methods.getFtsoWhitelistedPriceProviders(idx).call())
            ) as string[];
            const ftsoWhitelistsCounts = new Map( 
                symbols.map((c, i) => [c, ftsoWhitelists[i].length])
            );
            console.log(`FTSO Whitelist counts (before additional whitelisting):`);
            console.log(ftsoWhitelistsCounts);

            // Check to see if the account is not whitelisted for any FTSO
            // Saves on gas and time to not call whitelister contract if we're already whitelisted
            const includedInWhitelists = ftsoIndices.map(i => ftsoWhitelists[i].indexOf(cConfig.priceProviderAccount.address) >= 0);
            const numWhitelistedFtsos = includedInWhitelists.filter(x => x).length;
            if (numWhitelistedFtsos < ftsoIndices.length) {
                console.log(`Need to whitelist...`)
                // Whitelist ourselves for EVERY ftso. This always works in mock case
                // since there is no vote power calculation, so everyone gets whitelisted.
                // In a real setting, this call can be quite expensive and can potentially fail
                // if the voter does not have enough power or provide enough gas for the transaction
                const tx = voterWhitelister.methods.requestFullVoterWhitelisting(cConfig.priceProviderAccount.address).encodeABI();
                var transactionNonce = await cConfig.web3.eth.getTransactionCount(cConfig.priceProviderAccount.address);
                var gasPrice = await cConfig.web3.eth.getGasPrice();
                const transactionObject = {
                        chainId: 19,
                        nonce: cConfig.web3.utils.toHex(transactionNonce),
                        gasLimit: cConfig.web3.utils.toHex(8000000),
                        gasPrice: cConfig.web3.utils.toHex(gasPrice*1.2),
                        value: 0,
                        to: voterWhitelister.options.address,
                        from: cConfig.priceProviderAccount.address,
                        data: tx
                    };
                    
                const signedTx = await cConfig.web3.eth.accounts.signTransaction(transactionObject, `0x${cConfig.privKey}`);
                
                console.log(`\tWhitelisting: ${Date()}`);
                const result = await cConfig.web3.eth.sendSignedTransaction(signedTx.raw || signedTx.rawTransaction);
                // Check the whitelist for any changes
                const whitelist = await priceSubmitterContract.methods.voterWhitelistBitmap(cConfig.priceProviderAccount.address).call();

                // Get whitelists and counts after getting whitelisted
                const ftsoWhitelistsPost = await Promise.all(
                    ftsoSupportedIndices.map(async idx => await voterWhitelister.methods.getFtsoWhitelistedPriceProviders(idx).call())
                ) as string[];
                const ftsoWhitelistsCountsPost = new Map( 
                    symbols.map((c, i) => [c, ftsoWhitelistsPost[i].length])
                );
                console.log(`FTSO Whitelist counts (after whitelisting):`);
                console.log(ftsoWhitelistsCountsPost);
                // TODO(MCZ): set desired fee percentage
                // https://songbird-explorer.flare.network/address/0xc5738334b972745067fFa666040fdeADc66Cb925/write-contract
                // Use setDataProviderFeePercentage(bps)
                // Then delegate to your FTSO provider address via 
                // https://songbird-explorer.flare.network/address/0x02f0826ef6aD107Cfc861152B32B52fD11BaB9ED/write-contract
            } else {
                console.log(`Already whitelisted!`)
            }

            // Get submission config
            // Assumes uniform across all FTSOs (was in original Flare code)
            const {
                0: firstEpochStartTimeBN,
                1: submitPeriodBN,
                2: revealPeriodBN,
            } = (await ftsos[0].methods.getPriceEpochConfiguration().call());

            [firstEpochStartTime, submitPeriod, revealPeriod] = 
                [firstEpochStartTimeBN, submitPeriodBN, revealPeriodBN].map(x => parseInt(x));

            console.log(`FTSO parameters:`);
            console.log(`\tfirstEpochStartTime: ${new Date(firstEpochStartTime * 1000)}`);
            console.log(`\tsubmitPeriod (secs): ${submitPeriod}`);
            console.log(`\trevealPeriod (secs): ${revealPeriod}`);

            if (cConfig.checkPrices) {
                // Test: get prices for symbols
                var initialEpoch = Math.floor(((await getTime(cConfig.web3)) - firstEpochStartTime) / submitPeriod);
                // var pxsProd = await getPrices(1, symbols, new Array(symbols.length).fill(5));
        var pxsModel = await getPricesModel_USD_USDT_Weighted(initialEpoch, symbols);
        var pxsProd  = await getPrices(initialEpoch, symbols, decimals, cConfig.priceSource);    
        var pxsCcxt  = (await getPricesCCXT(symbols))[0];
                var pxsCC   = await getPricesCryptoCompare(symbols);
                var pxsCApi = await getPricesCoinApi(symbols);
                var pxsCMC  = await getPricesCMC(symbols);
                var pxsCG   = await getPricesCoinGecko(symbols);
                for (var i in ftsoSupportedIndices) {
                    console.log(`${symbols[i]}:`);
            	    console.log(`\tModel Price:   ${pxsModel[i]}`);
                    console.log(`\tCCXT:          ${pxsCcxt[i]}`);
                    console.log(`\tCryptoCompare: ${pxsCC  [i]}`);
                    console.log(`\tCoinAPI:       ${pxsCApi[i]}`);
                    console.log(`\tCoinMarketCap: ${pxsCMC [i]}`);
                    console.log(`\tCoinGecko:     ${pxsCG  [i]}`);
                    console.log(`\tProduction Px: ${pxsProd[i]}`);
                }
                console.log(`Price Source: ${cConfig.priceSource}`)
            }

            // We submitPriceHashes with the current EpochID, 
            // then once current Epoch is passed, within 90 seconds, we call revealPrices with EpochID 
            // (the same Epoch as submitPriceHashes and it should be currentEpoch - 1)
            // Since we only get rewarded if we're in the middle 50%, we need to make sure we submit at a good time
            // Based on txs from providers (see list https://flaremetrics.io/ftso/providers), most submit within last 15 seconds of an epoch
            // Reference functions in FtsoEpoch library:
            //      _epochSubmitStartTime
            //      _epochSubmitEndTime
            //      _epochRevealEndTime;    
            errorCount = 0;
            // sleep until submitBuffer seconds before the end of the epoch to maximize chance of being in interquartile range
            // Need a bit of buffer to let the other function calls return
            // Should be based on when others submit their prices to make sure we're as close as possible to them
            // submitBuffer = submitBufferBase + mean(submitTimes) + submitBufferStd*std(submitTimes)
            submitBuffer = cConfig.submitBufferMin;              // Initial buffer for how many seconds before end of epoch we should start submission
            // var submitBufferMin = 18;           // Minimum buffer
 	    submitBufferMax = 45;           // Maximum buffer
            submitTimes= [];     // Record recent times to measure how much buffer we need
            submitBufferStd = 3;            // How many stds (normal)
            // var submitBufferDecay = 0.999;      // Decay factor on each loop
            // var submitBufferIncrease = 1.1;     // Increase factor (multiple of std) for when we miss a submission window
            submitBufferBase = 3;           // Base buffer rate.
            submitBufferBurnIn = 5;        // Number of periods before adjusting submitBuffer
            now = await getTime(cConfig.web3);
            currentEpoch = 0;
            nextEpoch = currentEpoch;
            diff = 0;
            shouldInitialize = false;
        }
        // Get time and current epoch params
        now = await getTime(cConfig.web3);
        // now = (new Date()).getTime() / 1000; // susceptible to system clock drift
        const currentEpochCheck = (Math.floor((now - firstEpochStartTime) / submitPeriod)); // don't add 1 here like above
        // check for drift
        if (currentEpoch < currentEpochCheck) {
            currentEpoch = currentEpochCheck;
            nextEpoch = currentEpoch + 1;
        }
        const start = currentEpoch * submitPeriod + firstEpochStartTime;
        let next = nextEpoch * submitPeriod + firstEpochStartTime;
        const submitWaitTime = Math.max(Math.floor(next - now) - submitBuffer, 0);  // don't wait negative time

        console.log("\n\nEpoch ", currentEpoch); 
        console.log(`\tEpoch start time: ${new Date(start * 1000)}`);
        console.log(`\tCurrent time:     ${new Date(now * 1000)}`);
        console.log(`\tEpoch end time:   ${new Date(next * 1000)}`);
        console.log(`\tWaiting for ${submitWaitTime} seconds before getting price`); 
        await sleep(submitWaitTime * 1000);

        var startSubmitTime: Date = new Date();
        if (cConfig.isTestnet) {
            // Force hardhat to mine a new block which will have an updated timestamp. if we don't hardhat timestamp will not update.
            time.advanceBlock();    
        }
        console.log(`Start submit for epoch ${currentEpoch}`);
        console.log(`\tStart getting prices:    ${Date()}`); 
        // Prepare prices and randoms
        // const randoms = symbols.map(sym => web3.utils.randomHex(32)); 
        const randoms = symbols.map(sym => getRandom(currentEpoch, sym as string));

        // const prices = symbols.map(sym => getPrice(currentEpoch, sym)); // Just a mock here, real price should not be random
        const prices = await getPrices(currentEpoch, symbols as string[], decimals, cConfig.priceSource);

        console.log(`\tFinished getting prices: ${Date()}`); 

        const hashes = prices.map((p, i) => 
            submitPriceHash(p, randoms[i], cConfig.priceProviderAccount.address, cConfig.web3)
        );
        console.log(`\tFinished getting hashes: ${Date()}`); 
        console.log("Prices:  ", prices);
        console.log("Randoms: ", randoms);
        // occasionally, the submission will happen too late.
        // Catch those errors and continue
        var submittedHash: boolean;
        
        try {

            // const exchangeEncodeABI = priceSubmitterContract.methods.submitPriceHashes(currentEpoch,ftsoIndices, hashes).encodeABI();
            // var transactionNonce = await web3.eth.getTransactionCount(cConfig.priceProviderAccount.address);
            // var gasPrice = await web3.eth.getGasPrice();
            // const transactionObject = {
            //     chainId: 19,                                    // TODO: parameterize
            //     nonce: web3.utils.toHex(transactionNonce),
            //     gasLimit: web3.utils.toHex(469532),
            //     gasPrice: web3.utils.toHex(gasPrice*1.2),
            //     value: 0,
            //     to: priceSubmitterAddr,
            //     from: cConfig.priceProviderAccount.address,
            //     data: exchangeEncodeABI
            // };
            // const result : any[] = [];
            // // const signPromise = web3.eth.accounts.signTransaction(transactionObject, `0x${privKey}`);
            // // signPromise.then((signedTx) => {  
            // //     // raw transaction string may be available in .raw or 
            // //     // .rawTransaction depending on which signTransaction
            // //     // function was called
            // //     console.log(`\tSubmitting price hashes:       ${Date()}`)
            // //     const tx = web3_backup.eth.sendSignedTransaction(signedTx.raw || signedTx.rawTransaction);
            // //     console.log(`\tFirst Provider timestamp:      ${Date()}`); 

            // //     result.push(tx);
            // //     result.push(web3.eth.sendSignedTransaction(signedTx.raw || signedTx.rawTransaction));
            // //     console.log(`\tSecond Provider timestamp:     ${Date()}`); 
            // //     tx.once('transactionHash',  async hash => {
            // //         console.log("SubmitPriceHash txHash: ", hash);
            // //     })
                
            // // });

            // const signedTx = await web3.eth.accounts.signTransaction(transactionObject, `0x${privKey}`);
            // // raw transaction string may be available in .raw or 
            // // .rawTransaction depending on which signTransaction
            // // function was called
            // console.log(`\tPID ${process.pid} Submitting price hashes:       ${Date()}`)
            // const tx = web3_backup.eth.sendSignedTransaction(signedTx.raw || signedTx.rawTransaction);
            // console.log(`\tPID ${process.pid} First Provider timestamp:      ${Date()}`); 

            // result.push(tx);
            // if (web3._provider.host != web3_backup._provider.host) {
            //     result.push(web3.eth.sendSignedTransaction(signedTx.raw || signedTx.rawTransaction));
            //     console.log(`\tPID ${process.pid} Second Provider timestamp:     ${Date()}`); 
            // }
            // tx.once('transactionHash',  async hash => {
            //     console.log("SubmitPriceHash txHash: ", hash);
            // })

            
            // await Promise.all(result);

            console.log(`Submitting Price Hashes from: ${cConfig.priceProviderAccount.address}`)
            var gasPrice = await cConfig.web3.eth.getGasPrice();
            var submission = await priceSubmitterContract.methods.submitPriceHashes(currentEpoch, ftsoIndices, hashes).send(
                {
                    from: cConfig.priceProviderAccount.address,
                    gas: cConfig.web3.utils.toHex(469532),
                    gasPrice: cConfig.web3.utils.toHex(gasPrice*1.2),
                }
            );
            console.log(`\tFinished submission:     ${Date()}`); 
        
            submittedHash = true;
        } catch (error) {
            // TODO(MCZ): add notifications
            submittedHash = false;
            console.log(`\tError submitting price hashes:     ${Date()}`); 
            console.log(error);
            errorCount += 1;
            // if this is due to late submission, then we need to increase our buffer
            // TODO(MCZ): change to analyzing the timestamp of the failed transaction - not easy to do with Hardhat errors
            // Sometimes this will be submitted in time but not confirmed in time, in which case we get a tx id
            // Otherwise, just an error saying:
            //      Uncaught Error: Returned error: execution reverted: Wrong epoch id
            // Ref: https://gitlab.com/flarenetwork/flare-smart-contracts/-/blob/master/contracts/ftso/implementation/Ftso.sol#L634

            // const errorTime = await getTime();  // need to use blockchain time, or else the below condition may not fire
            // if (errorTime >= next) {
            //     submitBuffer = Math.min(submitBuffer + 1, submitPeriod);    // cap buffer at submitPeriod
            //     console.log(`Increasing submit buffer to ${submitBuffer} seconds`);
            // }

            // TODO(MCZ): also account for other network/provider issues, e.g. RPC node goes down
            // Can use Towo as backup node
            // https://hardhat.org/plugins/hardhat-change-network.html

            // Send error message
            // send mail with defined transport object
            try {
                let info = await cConfig.transporter.sendMail({
                    from: `"FTSO Monitor" <${cConfig.gmail_user}@gmail.com>`,                      // sender address
                    to: `${cConfig.error_mail_list}`,                                              // list of receivers
                    subject: `FTSO error for ${cConfig.priceProviderAccount.address}`,                         // Subject line
                    text: `Price hash submission error for ${cConfig.priceProviderAccount.address}`,        // plain text body
                    html: `Price hash submission error for <b>${cConfig.priceProviderAccount.address}</b>`, // html body
                });
            }
            catch (error)
            {
                console.log(`\tError Sending mail:     ${Date()}`);
                console.log(error);
            }
        }
        var endSubmitTime: Date = new Date();
        var submitTime = (endSubmitTime.getTime() - startSubmitTime.getTime()) / 1000;   // in seconds
        var nSubmitTimes = submitTimes.push(submitTime);
        // only store latest 1000 times
        if (nSubmitTimes > 1000) {
            submitTimes.shift();
        }
        // modify submit buffer based on recent observed times
        var submitMean = math.mean(submitTimes);
        var submitStd = math.std(submitTimes);
        console.log(`\nSubmit Buffer update:`);
        console.log(`   Prev: ${submitBuffer}`);
        // require a minimum sample size for updates
        if (nSubmitTimes > submitBufferBurnIn && !cConfig.constantBuffer) {
            // new submitBuffer in seconds
            submitBuffer = submitBufferBase + submitMean + submitBufferStd*submitStd;
            if(submitBuffer < cConfig.submitBufferMin) {
                submitBuffer = cConfig.submitBufferMin;
	    } else if (submitBuffer > submitBufferMax) {
	                submitBuffer = submitBufferMax;
	            }
        }
        console.log(`   New:  ${submitBuffer}`);
        console.log(`   Mean: ${submitMean}`);
        console.log(`   Std:  ${submitStd}`);
        console.log(`   Last: ${submitTime}`);

        // advance to start of reveal period
        now = await getTime(cConfig.web3);
        next = nextEpoch * submitPeriod + firstEpochStartTime;
        diff = Math.max(Math.floor(next + 5 - now), 0);     // have buffer of 5 seconds to ensure we're in the reveal period
        // TODO: catch "Reveal period not active" error
        console.log(`\nWaiting for ${diff} seconds until reveal`); 
        await sleep(diff * 1000);
        
        // Reveal prices
        console.log(`\n\tWoke at:                 ${Date()}`); 
        if (cConfig.isTestnet) {
            time.advanceBlock();
        }
        // Only reveal if we successfully submitted
        if (submittedHash) {
            console.log(`\tSubmitting price reveal: ${Date()}`)
            try {
                
                // const exchangeEncodeABI = priceSubmitterContract.methods.revealPrices(currentEpoch, ftsoIndices, prices, randoms).encodeABI();
                // var gasLimit = await priceSubmitterContract.methods.revealPrices(currentEpoch, ftsoIndices, prices, randoms).estimateGas({from: cConfig.priceProviderAccount.address});
                // var transactionNonce = await web3.eth.getTransactionCount(cConfig.priceProviderAccount.address);
                // var gasPrice = await web3.eth.getGasPrice();
                // const transactionObject = {
                //     chainId: 19,
                //     nonce: web3.utils.toHex(transactionNonce),
                //     gasLimit: web3.utils.toHex(gasLimit),
                //     gasPrice: web3.utils.toHex(gasPrice),
                //     value: 0,
                //     to: priceSubmitterAddr,
                //     from: cConfig.priceProviderAccount.address,
                //     data: exchangeEncodeABI
                // };
                // const result : any[] = [];


                // // const signPromise = web3.eth.accounts.signTransaction(transactionObject, `0x${privKey}`)
                // // .then(signedTx => web3.eth.sendSignedTransaction(signedTx.raw || signedTx.rawTransaction))
                // // .then(receipt => console.log(`\tFinished reveal:         ${Date()}`))
                // // .catch(err => console.error(err));


                // const signedTx = await web3.eth.accounts.signTransaction(transactionObject, `0x${privKey}`);
                // // raw transaction string may be available in .raw or 
                // // .rawTransaction depending on which signTransaction
                // // function was called
                // const tx = web3_backup.eth.sendSignedTransaction(signedTx.raw || signedTx.rawTransaction);
                // result.push(tx);
                // if (web3._provider.host != web3_backup._provider.host) {
                //     result.push(web3.eth.sendSignedTransaction(signedTx.raw || signedTx.rawTransaction));
                // }
                // tx.once('transactionHash',  async hash => {
                //     console.log("txHash: ", hash);
                // })
                // await Promise.all(result)


                console.log(`Revealing Prices from: ${cConfig.priceProviderAccount.address}`)
                var gasPrice = await cConfig.web3.eth.getGasPrice();
                var gasLimit = await priceSubmitterContract.methods.revealPrices(currentEpoch, ftsoIndices, prices, randoms).estimateGas({from: cConfig.priceProviderAccount.address});
                var submission = await priceSubmitterContract.methods.revealPrices(currentEpoch, ftsoIndices, prices, randoms).send(
                    {
                        from: cConfig.priceProviderAccount.address,
                        gas: gasLimit,
                        gasPrice: cConfig.web3.utils.toHex(gasPrice*1.2),
                    }
                );
                console.log(`\tFinished reveal:         ${Date()}`); 

                console.log("Revealed prices for epoch ", currentEpoch);
            } catch (error) {
                console.log('Error submitting price reveals');
                console.log(error);
                errorCount += 1;

                try {  // Send error message
                    let info = await cConfig.transporter.sendMail({
                        from: `"FTSO Monitor" <${cConfig.gmail_user}@gmail.com>`,                      // sender address
                        to: `${cConfig.error_mail_list}`,                                              // list of receivers
                        subject: `FTSO error for ${cConfig.priceProviderAccount.address}`,                         // Subject line
                        text: `Price reveal submission error for ${cConfig.priceProviderAccount.address}`,         // plain text body
                        html: `Price reveal submission error for <b>${cConfig.priceProviderAccount.address}</b>`,  // html body
                    });
                }
                catch (error)
                {
                    console.log(`\tError Sending mail:     ${Date()}`);
                    console.log(error);
                }
            }
        }
        
        // start loop again, the next price submission epoch has already started since we're in reveal phase
        // increment epoch
        currentEpoch = nextEpoch;
        nextEpoch = nextEpoch + 1

        // get remaining balance
        sgbBalance = fromWei((await cConfig.web3.eth.getBalance(cConfig.priceProviderAccount.address)).toString());
        console.log(`SGB remaining: ${sgbBalance}`);
        console.log(`Total errors now ${errorCount}`);
    }
}
   
main()
    .then(() => process.exit(0))
    .catch(error => {
    console.error(error);
    process.exit(1);
});

